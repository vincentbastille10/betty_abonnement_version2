--- a/app.py
+++ b/app.py
@@ -1,12 +1,13 @@
 # app.py
 from __future__ import annotations
 
-from flask import Flask, render_template, request, jsonify, redirect, url_for, session, send_from_directory, Response
+from flask import Flask, render_template, request, jsonify, redirect, url_for, session, send_from_directory, Response, make_response
 import os, yaml, requests, re, stripe, json, uuid, hashlib, sqlite3, time, base64
 from pathlib import Path
 from contextlib import contextmanager
 from urllib.parse import urlencode
 from jinja2 import TemplateNotFound
+from typing import Optional
 
 app = Flask(__name__)
 app.secret_key = os.getenv("FLASK_SECRET_KEY", "dev-secret-change-me")
@@ -22,6 +23,9 @@
 LLM_MODEL = os.getenv("LLM_MODEL", "meta-llama/Meta-Llama-3.1-8B-Instruct-Turbo").strip()
 LLM_MAX_TOKENS = int(os.getenv("LLM_MAX_TOKENS", "180"))
 
+DEBUG_MODE = os.getenv("DEBUG", "").lower() == "true"
+ALLOWED_ORIGINS = [o for o in (os.getenv("ALLOWED_ORIGINS","") or BASE_URL).split(",") if o]
+
 stripe.api_key = os.getenv("STRIPE_SECRET_KEY", "").strip()
 PRICE_ID = os.getenv("STRIPE_PRICE_ID", "").strip()
 
@@ -35,6 +39,7 @@
 
 app.jinja_env.globals["BASE_URL"] = BASE_URL
 
+# ---------------- DB ----------------
 # DB path resolution
 def pick_db_path() -> Path:
     env_forced = os.getenv("DB_PATH")
@@ -50,9 +55,11 @@
 DB_PATH = pick_db_path()
 
 @contextmanager
 def db_connect():
-    con = sqlite3.connect(str(DB_PATH))
+    # Thread-safe + moins de verrous en charges concurrentes
+    con = sqlite3.connect(str(DB_PATH), check_same_thread=False)
     con.row_factory = sqlite3.Row
     try:
+        con.execute("PRAGMA journal_mode=WAL;")
         yield con
     finally:
         con.close()
@@ -118,6 +125,28 @@
 def static_url(filename: str) -> str:
     return url_for("static", filename=filename)
 
+def _mask_email(s: Optional[str]) -> str:
+    s = (s or "").strip()
+    if not s or "@" not in s:
+        return s
+    local, domain = s.split("@", 1)
+    if not local:
+        return "***@" + domain
+    return local[0] + "***@" + domain
+
+def normalize_phone(s: str) -> str:
+    """Normalise approximativement vers E.164 FR quand possible."""
+    s = re.sub(r"[^\d+]", "", s or "")
+    if s.startswith("00"):
+        s = "+" + s[2:]
+    if s.startswith("0") and not s.startswith("+"):
+        # Par défaut FR si 0 initial
+        s = "+33" + s[1:]
+    # Coupe les numéros beaucoup trop longs
+    if len(s) > 20:
+        s = s[:20]
+    return s
+
 def parse_contact_info(raw: str) -> dict:
     raw = (raw or "").strip()
     if not raw:
         return {"raw": "", "name": "", "email": "", "phone": "", "address": "", "hours": ""}
@@ -179,6 +208,9 @@
     greet = f"\nMessage d'accueil recommandé : {greeting}\n" if greeting else ""
     return f"{base}\n{biz}\n{guide}\n{greet}"
 
+# ---------------- LLM ----------------
+# (inchangé, mais utilisera le prompt demo plus bas)
+
 # LLM call
 def call_llm_with_history(system_prompt: str, history: list, user_input: str) -> str:
     if not TOGETHER_API_KEY:
@@ -241,6 +273,8 @@
     if m: d["phone"] = m.group(1).strip()
     m = re.search(
     r"(?:je m(?:'|e)appelle|nom\s*:?)\s*([A-Za-zÀ-ÖØ-öø-ÿ'\-\s]{2,80})",
     user_text,
     re.I
 )
@@ -254,6 +288,8 @@
     if m: d["availability"] = m.group(0).strip()
     if d["phone"] and d["name"] and d["email"]:
         d["stage"] = "ready"
+    # Normalise téléphone
+    d["phone"] = normalize_phone(d["phone"])
     return d
 
 def rule_based_next_question(pack: str, history: list) -> str:
@@ -276,6 +312,7 @@
 def send_lead_email(to_email: str, lead: dict, bot_name: str = "Betty Bot"):
     if not (MJ_API_KEY and MJ_API_SECRET and to_email):
         print("[LEAD][MAILJET] Config manquante ou email vide, email non envoyé.")
         return
     subject = f"Nouveau lead qualifié via {bot_name}"
@@ -289,9 +326,12 @@
     payload = {
         "Messages": [{
             "From": {"Email": MJ_FROM_EMAIL, "Name": MJ_FROM_NAME},
             "To":   [{"Email": to_email}],
+            "ReplyTo": {"Email": lead.get("email",""), "Name": lead.get("name","")},
             "Subject": subject,
             "TextPart": text
         }]
     }
@@ -335,6 +375,7 @@
 def _gen_public_id(email: str, bot_key: str) -> str:
     h = hashlib.sha1((email + "|" + bot_key).encode()).hexdigest()[:8]
     return f"{bot_key}-{h}"
 
+# ---------------- Security: Origin & CORS ----------------
 def find_bot_by_public_id(public_id: str):
     if not public_id:
         return None, None
@@ -353,6 +394,32 @@
     b2 = dict(b); b2["bot_key"] = bot_key; b2["public_id"] = public_id
     return bot_key, b2
 
+@app.before_request
+def check_origin():
+    # Filtre origin pour POST API uniquement
+    if request.method == "POST" and request.path.startswith("/api/"):
+        origin = request.headers.get("Origin")
+        if origin and not any(origin.startswith(o) for o in ALLOWED_ORIGINS):
+            return jsonify({"error": "forbidden_origin"}), 403
+
+@app.after_request
+def add_cors_headers(resp):
+    origin = request.headers.get("Origin")
+    if origin and any(origin.startswith(o) for o in ALLOWED_ORIGINS):
+        resp.headers["Access-Control-Allow-Origin"] = origin
+        resp.headers["Vary"] = "Origin"
+        resp.headers["Access-Control-Allow-Credentials"] = "true"
+        resp.headers["Access-Control-Allow-Headers"] = "Content-Type, Authorization"
+        resp.headers["Access-Control-Allow-Methods"] = "GET, POST, OPTIONS"
+    return resp
+
+# ---------------- Pages ----------------
 CONVS = {}
 
 # PAGES
 @app.route("/")
 def index():
@@ -507,9 +574,14 @@
     demo_mode = (public_id == "spectra-demo")
 
     if demo_mode:
-        system_prompt = "..."  # short demo prompt (kept small to avoid blank)
+        system_prompt = (
+            "Tu es l’assistante de démo. Va droit au but : demande le téléphone, puis le nom complet, "
+            "puis l’email. Quand tu as les trois, confirme la transmission. "
+            "Style très bref (1–2 phrases). Termine toujours par une seule ligne LEAD_JSON."
+        )
     else:
         system_prompt = build_system_prompt(bot.get("pack", "avocat"), bot.get("profile", {}), bot.get("greeting", ""))
 
     full_text = call_llm_with_history(system_prompt=system_prompt, history=history, user_input=user_input)
     if not full_text:
         full_text = rule_based_next_question(bot.get("pack",""), history + [{"role":"user","content": user_input}])
@@ -522,7 +594,7 @@
     if conv_id:
         CONVS[conv_id] = history
     else:
         session[f"conv_{public_id or bot_key}"] = history
 
-    # send email if ready
+    # send email if ready (avec fallback destinataire)
     if True:
         if not lead or not isinstance(lead, dict):
             lead = _lead_from_history(history + [{"role": "user", "content": user_input}])
@@ -530,14 +602,23 @@
         stage_ok = bool(lead.get("phone")) and bool(lead.get("name")) and bool(lead.get("email"))
         if stage_ok:
-            buyer_email = buyer_email_ctx
+            # Normalise avant envoi
+            lead["phone"] = normalize_phone(lead.get("phone",""))
+
+            buyer_email = buyer_email_ctx or os.getenv("LEADS_FALLBACK_EMAIL","").strip()
             if not buyer_email:
-                app.logger.warning(f"[LEAD] buyer_email introuvable pour bot_id={public_id or 'N/A'} ; email non envoyé.")
+                app.logger.warning(f"[LEAD] destinataire introuvable pour bot_id={public_id or 'N/A'} ; email non envoyé.")
             else:
                 try:
                     send_lead_email(
                         to_email=buyer_email,
                         lead={
                             "reason": lead.get("reason", ""),
                             "name": lead.get("name", ""),
                             "email": lead.get("email", ""),
-                            "phone": lead.get("phone", ""),
+                            "phone": normalize_phone(lead.get("phone", "")),
                             "availability": lead.get("availability", ""),
                             "stage": "ready",
                         },
                         bot_name=(bot or {}).get("name") or "Betty Bot",
                     )
-                    app.logger.info(f"[LEAD] Email envoyé à {buyer_email} pour bot {public_id}")
+                    app.logger.info(f"[LEAD] Email envoyé à {_mask_email(buyer_email)} pour bot {public_id}")
                 except Exception as e:
                     app.logger.exception(f"[LEAD] Erreur envoi email -> {e}")
 
     return jsonify({
         "response": response_text,
-        "stage": (lead or {}).get("stage") if lead else None
+        "stage": (lead or {}).get("stage") if lead else ("ready_but_no_recipient" if stage_ok and not buyer_email_ctx and not os.getenv("LEADS_FALLBACK_EMAIL") else None)
     })
 
@@ -586,12 +667,17 @@
     if key and key in CONVS:
         CONVS.pop(key, None)
     return jsonify({"ok": True})
 
 @app.route("/api/test_mailjet")
 def test_mailjet():
-    to = (request.args.get("to") or os.getenv("TEST_TO_EMAIL") or "").strip()
+    if not DEBUG_MODE:
+        return jsonify({"ok": False, "error": "disabled_in_production"}), 403
+    to = (request.args.get("to") or os.getenv("TEST_TO_EMAIL") or "").strip()
     if not to:
         return jsonify({"ok": False, "error": "missing 'to' param"}), 400
     lead = {
         "reason": "Test automatique",
         "name": "Lead Test",
         "email": "lead@example.com",
         "phone": "+33000000000",
         "availability": "demain 10h",
         "stage": "ready",
     }
     send_lead_email(to, lead, bot_name="Betty Bot (test)")
     return jsonify({"ok": True, "to": to})
 
+# ---------------- Stripe webhook ----------------
+STRIPE_WEBHOOK_SECRET = os.getenv("STRIPE_WEBHOOK_SECRET", "").strip()
+
+@app.post("/webhook/stripe")
+def stripe_webhook():
+    if not STRIPE_WEBHOOK_SECRET:
+        return jsonify({"ok": False, "error": "webhook_not_configured"}), 501
+    sig = request.headers.get("Stripe-Signature", "")
+    payload = request.data
+    try:
+        event = stripe.Webhook.construct_event(payload, sig, STRIPE_WEBHOOK_SECRET)
+    except Exception as e:
+        return jsonify({"ok": False, "error": f"invalid_signature: {type(e).__name__}"}), 400
+
+    etype = event.get("type")
+    data = event.get("data", {}).get("object", {}) or {}
+
+    # checkout.session.completed : on valide le bot lié à public_id
+    if etype == "checkout.session.completed":
+        meta = data.get("metadata") or {}
+        public_id = meta.get("public_id") or ""
+        buyer = (data.get("customer_details") or {}).get("email") or ""
+        if public_id:
+            # Pas de champ 'status' dans la table, on ré-upsert pour conserver buyer_email
+            bot = db_get_bot(public_id)
+            if bot:
+                bot["buyer_email"] = buyer or bot.get("buyer_email") or ""
+                db_upsert_bot(bot)
+                # Mail de bienvenue optionnel
+                if buyer:
+                    send_lead_email(
+                        to_email=buyer,
+                        lead={"reason":"Bienvenue", "name":"", "email":buyer, "phone":"", "availability":"", "stage":"ready"},
+                        bot_name=bot.get("name") or "Betty Bot"
+                    )
+    # customer.subscription.updated : à capter au besoin (pause/resume/cancel)
+
+    return jsonify({"ok": True})
+
 @app.route("/avatar/<slug>")
 def avatar(slug: str):
     static_dir = os.path.join(app.root_path, "static")
     filename = f"logo-{slug}.jpg"
     path = os.path.join(static_dir, filename)
@@ -603,5 +689,5 @@
     return Response(transparent_png, mimetype="image/png")
 
 if __name__ == "__main__":
-    app.run(host="0.0.0.0", port=5000, debug=True)
+    app.run(host="0.0.0.0", port=5000, debug=DEBUG_MODE)
